#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import rclpy
from rclpy.node import Node
from std_msgs.msg import Int32
import gpiod
import threading

class EncoderNode(Node):
    def __init__(self):
        super().__init__('rpi5_encoder_node')
        # 參數: 每圈脈衝數 & 發布頻率
        self.declare_parameter('pulses_per_rev', 388)
        self.declare_parameter('publish_frequency', 10.0)
        self.ppr = self.get_parameter('pulses_per_rev').value
        freq = self.get_parameter('publish_frequency').value

        # 打開同一顆 chip，配置 A/B 腳位
        chip = gpiod.Chip('gpiochip4')
        self.line_left_a  = chip.get_line(22)
        self.line_left_b  = chip.get_line(23)
        self.line_right_a = chip.get_line(5)
        self.line_right_b = chip.get_line(6)

        # A 相邊緣中斷，B 相作為方向判斷
        self.line_left_a.request(consumer='enc_la', type=gpiod.LINE_REQ_EV_BOTH_EDGES)
        self.line_left_b.request(consumer='enc_lb', type=gpiod.LINE_REQ_DIR_IN)
        self.line_right_a.request(consumer='enc_ra', type=gpiod.LINE_REQ_EV_BOTH_EDGES)
        self.line_right_b.request(consumer='enc_rb', type=gpiod.LINE_REQ_DIR_IN)

        # 計數器與鎖
        self.counts = {'left': 0, 'right': 0}
        self.last_counts = {'left': 0, 'right': 0}
        self._lock = threading.Lock()

        # 啟動監測執行緒
        threading.Thread(target=self._monitor, args=(self.line_left_a, self.line_left_b, 'left'),  daemon=True).start()
        threading.Thread(target=self._monitor, args=(self.line_right_a, self.line_right_b, 'right'), daemon=True).start()

        # Publisher: 增量脈衝輸出
        self.pub_l = self.create_publisher(Int32, '/wheel/encoder_left',  10)
        self.pub_r = self.create_publisher(Int32, '/wheel/encoder_right', 10)

        # 定時器: 按頻率發布增量
        timer_period = 1.0 / freq
        self.create_timer(timer_period, self._timer_cb)

    def _monitor(self, line_a, line_b, side):
        """
        監測 A 相邊緣變化，每次 event_read 後讀取 A/B 值，計算方向。
        """
        while rclpy.ok():
            # 阻塞等候最多 1s
            if line_a.event_wait(timeout_sec=1):
                _ = line_a.event_read()
                a_val = line_a.get_value()
                b_val = line_b.get_value()
                # 正反方向判斷
                delta = 1 if (a_val != b_val) else -1
                with self._lock:
                    self.counts[side] += delta

    def _timer_cb(self):
        """
        每次定時發布自上次以來的脈衝增量，並重置 last_counts。
        """
        with self._lock:
            dl = self.counts['left']  - self.last_counts['left']
            dr = self.counts['right'] - self.last_counts['right']
            self.last_counts['left'], self.last_counts['right'] = \
                self.counts['left'], self.counts['right']

        # 發布增量脈衝
        self.pub_l.publish(Int32(data=dl))
        self.pub_r.publish(Int32(data=dr))


def main(args=None):
    rclpy.init(args=args)
    node = EncoderNode()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()
